<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[认识Java：对象的初始化]]></title>
    <url>%2F08%2F27%2Fobject-initialization.html</url>
    <content type="text"><![CDATA[我们知道，一个对象在实例化之前，必须要正确地初始化。初始化是指，在类加载过程中的初始化阶段，变量按照程序猿的意图进行赋值的过程；而实例化是指，在类完全加载到内存中后创建对象的过程。 生命周期 初始化方式 创建类的新实例–new 调用类和接口的静态方法 调用类和接口的静态字段（final字段除外） 调用Java的特定的反射方法； 初始化一个类的子类 指定一个类作为Java虚拟机启动时的初始化类（含有main方法的启动类） 使用对象的clone方法 反序列化对象 初始化的顺序 在Java对象初始化过程中，主要涉及三种对象初始化的结构，分别是变量初始化、代码块初始化和构造器初始化。Java要求在实例化之前，必须先实例化其超类，以保证所创建实例的完整性。 首先，通过某种初始化方式触发对象的初始化，接着Java解释器会查找类路径，然后定位并载入.class文件（这里将会创建一个Class对象），有关静态初始化的所有动作都会执行（静态初始化只执行一次），随后，创建对象的时候，JVM会为对象分配内存，而这块内存会自动清零，即对于每一个实例变量或类变量赋予默认值（这个时候实例变量或类变量被第一次赋值），之后执行实例变量定义处和代码块的初始化动作（如果有赋值操作，这时候实例变量就被第二次赋值了），最后执行构造器的初始化。 实例变量和类变量的初始化默认值 boolean: false char: [] byte、short、int、long: 0 float、double: 0.0 reference: null 初始化流程详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Demo1 &#123; public static void main(String[] args)&#123; System.out.println("*****************开始******************"); SuperMan xMan = new SuperMan(); xMan.enableStealth(); System.out.println("*****************结束******************"); &#125;&#125;class Person &#123; String name; int age; public Person() &#123; System.out.println("初始化构造器：Person()"); &#125; &#123; name = "派大星"; age = -1; System.out.println("初始化Person非静态代码块"); &#125;&#125;interface stealth &#123; int time = 1; void enableStealth();&#125;class EnergyStone &#123; static String color; String name; public EnergyStone(String name) &#123; this.name = name; System.out.println("初始化构造器：EnergyStone( name=" + name + ")"); &#125; &#123; name = "无名之石"; System.out.println("初始化EnergyStone非静态代码块：名字为" + name ); &#125; static &#123; color = "五彩斑斓的黑色"; System.out.println("初始化EnergyStone静态代码块：颜色为" + color ); &#125;&#125;class SuperMan extends Person implements stealth &#123; EnergyStone speedStone = new EnergyStone("乌龟之速"); static String origin = "M7星云"; &#123; powerStone = new EnergyStone("爆破之力"); defenseStone = new EnergyStone("低级防御"); System.out.println("初始化SuperMan非静态代码块。力量宝石：爆破之力，防御宝石：低级防御"); &#125; String type; static &#123; System.out.println("初始化SuperMan静态代码块。超人来源：" + origin); &#125; public SuperMan() &#123; System.out.println("初始化构造器：SuperMan( name=" + name + "， age=" + age + ", type=" + type + ")"); &#125; static EnergyStone lifeStone = new EnergyStone("永恒之源"); &#123; type = "力量型"; System.out.println("初始化SuperMan非静态代码块。超人类型：" + type); &#125; EnergyStone powerStone; @Override public void enableStealth() &#123; System.out.println("开启隐身"); &#125; EnergyStone defenseStone;&#125; 123456789101112131415161718*****************开始******************初始化SuperMan静态代码块。超人来源：M7星云初始化EnergyStone静态代码块：颜色为五彩斑斓的黑色初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=永恒之源)初始化Person非静态代码块初始化构造器：Person()初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=乌龟之速)初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=爆破之力)初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=低级防御)初始化SuperMan非静态代码块。力量宝石：爆破之力，防御宝石：低级防御初始化SuperMan非静态代码块。超人类型：力量型初始化构造器：SuperMan( name=派大星， age=-1, type=力量型)开启隐身*****************结束****************** 可以看出，当实例化XMan时会触发初始化，第一步，先执行静态初始化，XMan的类变量和静态代码块按顺序依次初始化，所以先初始化了XMan的类变量：origin（M7星云）和lifestone,而初始lifeStone时又会初始化它的类变量color（五彩斑斓的黑色），再接着初始化lifeStone的实例变量name（永恒之源）；第二步，初始化XMan的父类Person；第三步，按顺序依次初始化XMan的实例变量和非静态代码，所以依次实例化了speedStone（乌龟之速）、powerStone（爆破之力）和defenseStone（低级防御）以及非静态代码块，期间，也可以看出EnergyStone的类变量只会初始化一次；第四步，初始化构造器。 总结 总体来看，初始化的执行顺序为：静态代码块和类变量 -&gt; 父类 -&gt; 非静态代码块和实例变量 -&gt; 构造器。静态初始化只执行一次，并且变量和代码块的位置无论放在方法的前面还是后面，都不会因此影响初始化的顺序。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：值传递]]></title>
    <url>%2F08%2F26%2Fpass-by-value.html</url>
    <content type="text"><![CDATA[在数据传递的时候，Java是通过值传递的，也就是说通过拷贝传递。对于主数据类型来说，拷贝它实际的数值；引用类型也只是个变量值，并非是对象本身，所以拷贝的是对象的引用变量值。 概述 主数据类型： 整型：byte、short、int、long 浮点型：float，double 字符型：char 布尔型：boolean 引用类型： 数组 类 接口 形式参数：定义方法时接受数据的参数 实际参数：调用方法时传递数据的参数 值传递（pass by value）：在调用方法时将实际参数复制一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数 引用传递（pass by reference）：在调用方法时将实际参数的地址直接传递到方法中，那么在方法中对参数所进行的修改，将影响到实际参数 主数据类型传递 123456789101112public class Demo1 &#123; public static void main(String[] args) &#123; int x = 7; print(x); System.out.println("print in main method: x is " + x); &#125; public static void print(int x) &#123; x = 13; System.out.println("print in change method: x is " + x); &#125;&#125; 12print in change method: x is 13print in main method: x is 7 可见，change方法内部对x的值的修改并没有改变实际参数x的值。即Java中，主数据类型是值传递的。 引用类型传递 123456789101112public class Demo2 &#123; public static void main(String[] args)&#123; Dog dog = new Dog("哈士奇"); change(dog); System.out.println("print in main method: dog is " + dog); &#125; public static void change(Dog dog) &#123; dog = new Dog("拉布拉多"); System.out.println("print in change method: dog is " + dog); &#125;&#125; 12print in change method: dog is 拉布拉多print in main method: dog is 哈士奇 可见，change方法内部对dog的值的修改并没有改变实际参数dog的值。即Java中，引用类型是值传递的。 总结 在Java中无论什么传递都是值传递，主数据类型本身是数值，所以传递的值就是拷贝的数值，而引用本身是记录对象元数据的变量值，所以传递的值就是拷贝的引用变量值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：面向对象]]></title>
    <url>%2F07%2F17%2Fwhat-is-Java.html</url>
    <content type="text"><![CDATA[Java是一种面向对象的静态类型的强语言。采用垃圾自动回收机制通过垃圾收集器（Garbage Collector）回收分配内存，从而实现内存分配和回收的自动管理；采用JVM(Java Virtual Machine)作为运行环境，编译和解释相结合，能够非常容易地获得跨平台能力。 面向对象 概述 面向对象的思维是从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。万物皆为对象，对象具有状态、行为、和标识；程序是对象的集合，他们能通过发送信息来告诉彼此所要做的事情；每个对象都可以由其他对象复合而成；每个对象都拥有自己的类型；某一特定类型的所有对象都可以接受同样的信息。 三大特征 封装，把客观事物抽象成类，一个类就是封装了数据以及操作这些数据的代码的逻辑实体。进行封装后，通过访问权限控制，给对象的内部数据提供了不同级别的保护，从而防止程序意外地改变或错误地使用对象的数据。 继承，创建一个类后，如果另个新类与其具有相似之处，可以以现有的类为基础，复制它，然后进行修改和扩展。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 多态,在处理类型的层次结构时，不把一个对象当做它所属的特定类型对待，在不同情形有不同的表现形式。 五大基本原则 单一职责原则SRP(Single Responsibility Principle)，一个类的功能要尽量单一高内聚 开放封闭原则OCP(Open－Close Principle) ，一个类应该对扩展开放，对修改封闭 替换原则(the Liskov Substitution Principle LSP) ，父类的调用同样适用于子类 依赖原则(the Dependency Inversion Principle DIP)，具体依赖抽象，上层依赖下层 接口分离原则(the Interface Segregation Principle ISP)，针对接口编程，不针对实现编程 拓展 编译型与解释型 概述 编译型：把写好的源程序全部编译成二进制代码的可运行程序 解释型：对写好的源程序中的每行代码逐条解释并计算结果 确定语言的类型 一般，语言只会定义其抽象语义，而不会强制性要求采用某种实现方式，被称为解释型语言还是编译型语言取决于该语言实现程序可执行的主流方式，并不是说解释型语言它就无法编译，反之也是。例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，如Ch。同样，C++也有解释器版本的实现，如Cint。 Java是解释型的吗？ “Java是解释执行”这个说法其实并不太准确。我们开发的Java源代码，首先通过Javac编译成为字节码（bytecode），然后在Java虚拟机（JVM）上运行。而从字节码到在JVM上可运行有三种处理方式： 解释:.class文件经过JVM内嵌的解析器解释执行 编译:JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为&quot;热点代码&quot;编译成本地平台相关的机器码，并进行各种层次的优化 AOT编译器: Java9提供可直接将所有代码编译成可执行的机器码 动态型和静态型 动态类型语言：在运行期间进行类型检查，也就是说在编写代码的时候可以不指定变量的数据类型 静态类型语言：在编译期间进行类型检查，也就是说变量在使用前要声明变量的数据类型，这样的好处是提前检查可能出现的类型错误 强弱语言 强类型：偏向于不容忍隐式类型转换。譬如说Java的int就不能变成double 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double 一次编写，到处运行 一次编写，到处运行，“Write once, run anywhere” (WORA)，表明的是Java的跨平台能力。但是，真的如这句话说得一样完美吗？我想，并不完全是。 WORA是指应用程序生成的二进制文件，可以直接在其他的支持 Java 的平台上运行。 像Linux、Windows和Mac等，这些本质区别很大的平台，他们在一些系统核心调用方面可能存在完全不同的机制，兼容还是有一定的困难的。因而，更广泛意义上的跨平台其实还是比较难实现的。在服务器之外的领域，跨平台要解决的问题更多。 但是，在有限的情况下，完全使用标准jdk，无JNI，无特定硬件依赖的话，Java的跨平台能力还是很强的，利用虚拟机技术，屏蔽了底层硬件、系统的差异，只需把编译好的war、jar包放到已经安装好Java环境的Linux、Windows和Mac等平台下，使用相应的启动脚本，还是可以愉快地跑起来的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解git的快照？]]></title>
    <url>%2F10%2F20%2Fhow-to-understand-snapshot-in-git.html</url>
    <content type="text"><![CDATA[最近开始学习git的使用，发现snapshot这个术语，看得是朦朦胧胧😀，感觉理解这个词，又感觉不是很懂，所以就去网上搜索资料，尝试用自己的理解叙述出来🤔。 什么是快照 In computer systems, a snapshot is the state of a system at a particular point in time. 本人觉得快照并没含有’速度快’的意思。快照应该理解为整个系统或者应用在某个时刻的状态记录。例如，假定在A时刻，你的git工作空间分别有file1和file2，到B时刻的时候，你对file1进行了修改。 随后，在你准备进行一次commit之前，git就已经准备好快照了，这个快照记录了当前工作空间中指向未修改文件file2的指针和已经修改的file2数据（即当前时刻工作空间的文件数据状态）。因此，commit的时候，就等同于保存了一次快照。 快照怎么进行 git会读取当前工作空间的所有数据，进行数据预存，再重新调整。它会和上一次的快照版本的内容进行比较，对于没有改变的文件数据，git会把当前预存中冗余文件的数据去除掉，改为保留指向上一个版本中该文件数据的指针，对于有差异的文件数据就会保留下来，最终再把数据完整保存下来，这才算是执行了一次快照。 git和CVS,、Subversion等的区别 两者的差异在于对待保存数据的方式。前者是记录和组装一系列快照流的微型系统，关心文件数据的整体是否发生变化。每次commit的时候保存一次快照，而每个快照都包含了完整的数据；后者则关心文件内容的具体差异。第一次保存了完整的数据，往后每次保存的都不是完整的数据，只会记录基于之前的版本和现在两者的变化信息，对于此外没有变化的都不会去记录。 本文参考： . git . quoar]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
