<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[认识Java：自动装箱和拆箱]]></title>
    <url>%2Farticle%2Fautoboxing-and-unboxing.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：继承和多态]]></title>
    <url>%2Farticle%2Finheritance-and-polymorphic.html</url>
    <content type="text"><![CDATA[概述 方法签名：方法的名字和参数列表 重写（override）：子类中定义的方法，其方法名、参数列表和返回类型与父类中某个方法相匹配。重写只发生在继承中，子类可以重写父类的方法 重载（overload）：同一个类中，多个方法具有相同的方法名但其参数列表不同。参数列表的不同体现在：类型不同、个数不同、顺序不同 重载解析：编译器执行方法时，根据调用方法的方法签名挑选出相应的具体方法，并且执行它，如果不存在则产生编译错误 动态绑定（dynamic binding）：在执行期间判断所引用对象的实际类型，根据其实际类型调用其相应的方法 组合：将一系列的对象组合在一起，形成一个功能丰富的类 继承 创建一个类后，如果另个新类与其具有相似之处，可以以现有的类为基础，复制它，然后进行修改和扩展。通俗来讲，可以基于已经存在的类构造一个新的类，继承已存在类的方法和属性，还可以添加或者修改一些方法或者属性，来满足新的需求。“is-a&quot;是继承的一个明显特征，Dog is a animal，所以Dog类继承animal类是合理的。通过继承，可以达到最大程度的代码复用，但需要注意的是，Java是单根继承的，不支持多继承，不过这可以通过接口和内部类间接实现多继承的需求。 调用方法时，如果子类没有，就调用父类的同名方法 123456789101112131415161718public class Demo1 &#123; public static void main(String[] args)&#123; Dog dog = new Dog(); dog.sleep(); &#125;&#125;class Animal &#123; double weight; void sleep() &#123; System.out.println("Animal sleep"); &#125;&#125;class Dog extends Animal &#123;&#125; 1Animal sleep 调用方法时，如果子类重写父类的方法，就调用子类重写的方法 12345678910111213public class Demo1 &#123; public static void main(String[] args)&#123; Dog dog = new Dog(); dog.sleep(); &#125;&#125;class Dog extends Animal &#123; @Override void sleep() &#123; System.out.println("wang wang wang! Dog sleep"); &#125;&#125; 1wang wang wang! Dog sleep 多态 在处理类型的层次结构时，不把一个对象当做它所属的特定类型对待，在不同情形有不同的表现形式。多态的作用是，消除类型之间的耦合关系，增强可扩展性，可以灵活操作。例如，对于Circle类、Square类进行计算面积、绘制时，可以把它们当做Shape类看待，忘记它们真正的类型后都视为同一类型来处理。在方法调用时，可以通过动态绑定实现调用正确的方法。此时，再添加一个Triangle类，也能如期执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo2 &#123; public static void main(String[] args) &#123; Cricle cricle = new Cricle(2); compute(cricle); Square square = new Square(4); compute(square); &#125; static void compute(Shape shape) &#123; shape.computeArea(); &#125;&#125;abstract class Shape &#123; abstract void computeArea();&#125;class Cricle extends Shape &#123; double r; public Cricle(double r) &#123; this.r = r; &#125; @Override void computeArea() &#123; System.out.println("计算圆的面积:"+ (r*r*Math.PI)); &#125;&#125;class Square extends Shape &#123; double edge; public Square(double edge) &#123; this.edge = edge; &#125; @Override void computeArea() &#123; System.out.println("计算正方形面积:" + edge * edge); &#125;&#125; 12计算圆的面积:12.566370614359172计算正方形面积:16.0 继承 or 组合 一般来说，组合应优先于继承。虽然继承是实现代码重用的有力手段，但它并非是完成这项任务的最佳或者首要工具。继承会打破封装性，子类依赖父类中特定功能的实现细节。如果父类的实现发生改变，子类虽然没有改变代码，但是也可能会遭到破坏。因此，继承若是使用不当会导致软件变得很脆如。平常设计项目架构时，务必要精心设计继承关系，并且谨慎地实现，这样才能最大程度避免问题发生。 可以举个具体点的例子来阐明上述说法。假设A作者编写了BaseList类，像ArrayList、LinkList一样，能够动态存储一组元素并且记录储存的数目。B作者编写了SuperList，继承了BaseList并且能够记录它被创建以来曾经添加了多少次元素。 1234567891011121314151617181920212223242526272829303132class BaseList&lt;E&gt; &#123; int size; void add(E e) &#123; //添加操作 size++; &#125; void addAll(Collection&lt;E&gt; collection) &#123; //添加操作 size += collection.size(); &#125; //其他增删改查等方法&#125;class SuperList&lt;E&gt; extends BaseList&lt;E&gt;&#123; /** 添加元素次数统计*/ int addCount; @Override void add(E e) &#123; addCount++; super.add(e); &#125; @Override void addAll(Collection&lt;E&gt; c) &#123; addCount += c.size(); super.addAll(c); &#125;&#125; 接下来，A作者对BaseList的addAll方法做了修改 123456789101112131415161718192021222324252627282930class BaseList&lt;E&gt; &#123; int size; void add(E e) &#123; //添加操作 size++; &#125; /**修改后的addAll方法*/ void addAll(Collection&lt;E&gt; collection) &#123; Iterator it = collection.iterator(); for (; it.hasNext(); ) &#123; add((E) it.next()); &#125; &#125; //其他增删改查等方法&#125;public class Demo3 &#123; public static void main(String[] args) &#123; ArrayList apps = new ArrayList(); apps.add("qq"); apps.add("wechat"); apps.add("taobao"); SuperList superList = new SuperList(); superList.addAll(apps); System.out.println("添加元素次数统计：" + superList.addCount); &#125;&#125; 1添加元素次数统计：6 更改BaseList的addAll方法后，在调用SuperList的addAll方法时，会把集合元素数目的统计结果加到addCount中，之后调用父类的addAll方法；在父类BaseList的addAll方法中又调用了add方法，根据动态绑定，实际上是调用了SuperList覆盖父类的add方法，这样子就会遍历调用SuperList的add方法，addCount又再一次把集合元素数目的结果加了一遍；输出的时候，addCount正确应该是等于3.可是错误的变成了6。 随后，A作者撤销BaseList的addAll方法的修改，而B作者给SuperList添加了inverse方法 1234567class SuperList&lt;E&gt; extends BaseList&lt;E&gt; &#123; ......省略 boolean inverse() &#123; // 把列表的元素逆序排序，并且返回操作结果 &#125;&#125; 该方法投入使用一段时间后，BaseList的作者也添加了一个inverse方法 1234567class BaseList&lt;E&gt; &#123; ......省略 void inverse() &#123; // 把列表的元素逆序排序 &#125;&#125; 这个时候，SuperList的inverse方法的方法签名和父类BaseList相同，但是返回类型不一致。假设这时许多地方都使用了Super List的inverse方法，需要根据返回的布尔值做判断，发生了这种情况，可不是砍了BaseList的作者就能解决了。 时间倒流，如果我们选择使用组合 1234567891011121314151617181920class SuperList&lt;E&gt; &#123; BaseList provider = new BaseList(); int addCount; void add(E e) &#123; addCount++; provider.add(e); &#125; void addAll(Collection&lt;E&gt; c) &#123; addCount += c.size(); provider.addAll(c); &#125; boolean inverse() &#123; // 把provider列表的元素逆序排序,并且返回操作结果 &#125;&#125; 使用组合后，前面遇到的两种问题就能迎刃而解，很好地杜绝了继承带来的一些麻烦和困扰，一定程度也做到了代码复用。简而言之，如果子类和父类确实存在“is-a”关系时，使用继承是非常适合的，但是如果不存在“is-a”关系、父类不是为了继承而设计的或者子类和父类处在不同包中，应该尽量避免使用继承，这时不妨可以考虑一下使用组合。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：对象的初始化]]></title>
    <url>%2Farticle%2Fobject-initialization.html</url>
    <content type="text"><![CDATA[我们知道，一个对象在实例化之前，必须要正确地初始化。初始化是指，在类加载过程中的初始化阶段，变量按照程序猿的意图进行赋值的过程；而实例化是指，在类完全加载到内存中后创建对象的过程。 生命周期 初始化方式 创建类的新实例–new 调用类和接口的静态方法 调用类和接口的静态字段（final字段除外） 调用Java的特定的反射方法； 初始化一个类的子类 指定一个类作为Java虚拟机启动时的初始化类（含有main方法的启动类） 使用对象的clone方法 反序列化对象 初始化的顺序 在Java对象初始化过程中，主要涉及三种对象初始化的结构，分别是变量初始化、代码块初始化和构造器初始化。Java要求在实例化之前，必须先实例化其超类，以保证所创建实例的完整性。 首先，通过某种初始化方式触发对象的初始化，接着Java解释器会查找类路径，然后定位并载入.class文件（这里将会创建一个Class对象），有关静态初始化的所有动作都会执行（静态初始化只执行一次），随后，创建对象的时候，JVM会为对象分配内存，而这块内存会自动清零，即对于每一个实例变量或类变量赋予默认值（这个时候实例变量或类变量被第一次赋值），之后执行实例变量定义处和代码块的初始化动作（如果有赋值操作，这时候实例变量就被第二次赋值了），最后执行构造器的初始化。 实例变量和类变量的初始化默认值 boolean: false char: [] byte、short、int、long: 0 float、double: 0.0 reference: null 初始化流程详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Demo1 &#123; public static void main(String[] args)&#123; System.out.println("*****************开始******************"); SuperMan xMan = new SuperMan(); xMan.enableStealth(); System.out.println("*****************结束******************"); &#125;&#125;class Person &#123; String name; int age; public Person() &#123; System.out.println("初始化构造器：Person()"); &#125; &#123; name = "派大星"; age = -1; System.out.println("初始化Person非静态代码块"); &#125;&#125;interface stealth &#123; int time = 1; void enableStealth();&#125;class EnergyStone &#123; static String color; String name; public EnergyStone(String name) &#123; this.name = name; System.out.println("初始化构造器：EnergyStone( name=" + name + ")"); &#125; &#123; name = "无名之石"; System.out.println("初始化EnergyStone非静态代码块：名字为" + name ); &#125; static &#123; color = "五彩斑斓的黑色"; System.out.println("初始化EnergyStone静态代码块：颜色为" + color ); &#125;&#125;class SuperMan extends Person implements stealth &#123; EnergyStone speedStone = new EnergyStone("乌龟之速"); static String origin = "M7星云"; &#123; powerStone = new EnergyStone("爆破之力"); defenseStone = new EnergyStone("低级防御"); System.out.println("初始化SuperMan非静态代码块。力量宝石：爆破之力，防御宝石：低级防御"); &#125; String type; static &#123; System.out.println("初始化SuperMan静态代码块。超人来源：" + origin); &#125; public SuperMan() &#123; System.out.println("初始化构造器：SuperMan( name=" + name + "， age=" + age + ", type=" + type + ")"); &#125; static EnergyStone lifeStone = new EnergyStone("永恒之源"); &#123; type = "力量型"; System.out.println("初始化SuperMan非静态代码块。超人类型：" + type); &#125; EnergyStone powerStone; @Override public void enableStealth() &#123; System.out.println("开启隐身"); &#125; EnergyStone defenseStone;&#125; 123456789101112131415161718*****************开始******************初始化SuperMan静态代码块。超人来源：M7星云初始化EnergyStone静态代码块：颜色为五彩斑斓的黑色初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=永恒之源)初始化Person非静态代码块初始化构造器：Person()初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=乌龟之速)初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=爆破之力)初始化EnergyStone非静态代码块：名字为无名之石初始化构造器：EnergyStone( name=低级防御)初始化SuperMan非静态代码块。力量宝石：爆破之力，防御宝石：低级防御初始化SuperMan非静态代码块。超人类型：力量型初始化构造器：SuperMan( name=派大星， age=-1, type=力量型)开启隐身*****************结束****************** 可以看出，当实例化XMan时会触发初始化，第一步，先执行静态初始化，XMan的类变量和静态代码块按顺序依次初始化，所以先初始化了XMan的类变量：origin（M7星云）和lifestone,而初始lifeStone时又会初始化它的类变量color（五彩斑斓的黑色），再接着初始化lifeStone的实例变量name（永恒之源）；第二步，初始化XMan的父类Person；第三步，按顺序依次初始化XMan的实例变量和非静态代码，所以依次实例化了speedStone（乌龟之速）、powerStone（爆破之力）和defenseStone（低级防御）以及非静态代码块，期间，也可以看出EnergyStone的类变量只会初始化一次；第四步，初始化构造器。 总结 总体来看，初始化的执行顺序为：静态代码块和类变量 -&gt; 父类 -&gt; 非静态代码块和实例变量 -&gt; 构造器。静态初始化只执行一次，并且变量和代码块的位置无论放在方法的前面还是后面，都不会因此影响初始化的顺序。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：值传递]]></title>
    <url>%2Farticle%2Fpass-by-value.html</url>
    <content type="text"><![CDATA[在数据传递的时候，Java是通过值传递的，也就是说通过拷贝传递。对于主数据类型来说，拷贝它实际的数值；引用类型也只是个变量值，并非是对象本身，所以拷贝的是对象的引用变量值。 概述 主数据类型： 整型：byte、short、int、long 浮点型：float，double 字符型：char 布尔型：boolean 引用类型： 数组 类 接口 形式参数：定义方法时接受数据的参数 实际参数：调用方法时传递数据的参数 值传递（pass by value）：在调用方法时将实际参数复制一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数 引用传递（pass by reference）：在调用方法时将实际参数的地址直接传递到方法中，那么在方法中对参数所进行的修改，将影响到实际参数 主数据类型传递 123456789101112public class Demo1 &#123; public static void main(String[] args) &#123; int x = 7; print(x); System.out.println("print in main method: x is " + x); &#125; public static void print(int x) &#123; x = 13; System.out.println("print in change method: x is " + x); &#125;&#125; 12print in change method: x is 13print in main method: x is 7 可见，change方法内部对x的值的修改并没有改变实际参数x的值。即Java中，主数据类型是值传递的。 引用类型传递 123456789101112public class Demo2 &#123; public static void main(String[] args)&#123; Dog dog = new Dog("哈士奇"); change(dog); System.out.println("print in main method: dog is " + dog); &#125; public static void change(Dog dog) &#123; dog = new Dog("拉布拉多"); System.out.println("print in change method: dog is " + dog); &#125;&#125; 12print in change method: dog is 拉布拉多print in main method: dog is 哈士奇 可见，change方法内部对dog的值的修改并没有改变实际参数dog的值。即Java中，引用类型是值传递的。 总结 在Java中无论什么传递都是值传递，主数据类型本身是数值，所以传递的值就是拷贝的数值，而引用本身是记录对象元数据的变量值，所以传递的值就是拷贝的引用变量值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：面向对象]]></title>
    <url>%2Farticle%2Fwhat-is-Java.html</url>
    <content type="text"><![CDATA[Java是一种面向对象的静态类型的强语言。采用垃圾自动回收机制通过垃圾收集器（Garbage Collector）回收分配内存，从而实现内存分配和回收的自动管理；采用JVM(Java Virtual Machine)作为运行环境，编译和解释相结合，能够非常容易地获得跨平台能力。 面向对象 概述 面向对象的思维是从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。万物皆为对象，对象具有状态、行为、和标识；程序是对象的集合，他们能通过发送信息来告诉彼此所要做的事情；每个对象都可以由其他对象复合而成；每个对象都拥有自己的类型；某一特定类型的所有对象都可以接受同样的信息。 三大特征 封装，把客观事物抽象成类，一个类就是封装了数据以及操作这些数据的代码的逻辑实体。进行封装后，通过访问权限控制，给对象的内部数据提供了不同级别的保护，从而防止程序意外地改变或错误地使用对象的数据。 继承，创建一个类后，如果另个新类与其具有相似之处，可以以现有的类为基础，复制它，然后进行修改和扩展。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 多态,在处理类型的层次结构时，不把一个对象当做它所属的特定类型对待，在不同情形有不同的表现形式。 五大基本原则 单一职责原则SRP(Single Responsibility Principle)，一个类的功能要尽量单一高内聚 开放封闭原则OCP(Open－Close Principle) ，一个类应该对扩展开放，对修改封闭 替换原则(the Liskov Substitution Principle LSP) ，父类的调用同样适用于子类 依赖原则(the Dependency Inversion Principle DIP)，具体依赖抽象，上层依赖下层 接口分离原则(the Interface Segregation Principle ISP)，针对接口编程，不针对实现编程 拓展 编译型与解释型 概述 编译型：把写好的源程序全部编译成二进制代码的可运行程序 解释型：对写好的源程序中的每行代码逐条解释并计算结果 确定语言的类型 一般，语言只会定义其抽象语义，而不会强制性要求采用某种实现方式，被称为解释型语言还是编译型语言取决于该语言实现程序可执行的主流方式，并不是说解释型语言它就无法编译，反之也是。例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，如Ch。同样，C++也有解释器版本的实现，如Cint。 Java是解释型的吗？ “Java是解释执行”这个说法其实并不太准确。我们开发的Java源代码，首先通过Javac编译成为字节码（bytecode），然后在Java虚拟机（JVM）上运行。而从字节码到在JVM上可运行有三种处理方式： 解释:.class文件经过JVM内嵌的解析器解释执行 编译:JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为&quot;热点代码&quot;编译成本地平台相关的机器码，并进行各种层次的优化 AOT编译器: Java9提供可直接将所有代码编译成可执行的机器码 动态型和静态型 动态类型语言：在运行期间进行类型检查，也就是说在编写代码的时候可以不指定变量的数据类型 静态类型语言：在编译期间进行类型检查，也就是说变量在使用前要声明变量的数据类型，这样的好处是提前检查可能出现的类型错误 强弱语言 强类型：偏向于不容忍隐式类型转换。譬如说Java的int就不能变成double 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double 一次编写，到处运行 一次编写，到处运行，“Write once, run anywhere” (WORA)，表明的是Java的跨平台能力。但是，真的如这句话说得一样完美吗？我想，并不完全是。 WORA是指应用程序生成的二进制文件，可以直接在其他的支持 Java 的平台上运行。 像Linux、Windows和Mac等，这些本质区别很大的平台，他们在一些系统核心调用方面可能存在完全不同的机制，兼容还是有一定的困难的。因而，更广泛意义上的跨平台其实还是比较难实现的。在服务器之外的领域，跨平台要解决的问题更多。 但是，在有限的情况下，完全使用标准jdk，无JNI，无特定硬件依赖的话，Java的跨平台能力还是很强的，利用虚拟机技术，屏蔽了底层硬件、系统的差异，只需把编译好的war、jar包放到已经安装好Java环境的Linux、Windows和Mac等平台下，使用相应的启动脚本，还是可以愉快地跑起来的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Git的快照]]></title>
    <url>%2Farticle%2Fhow-to-understand-snapshot-in-git.html</url>
    <content type="text"><![CDATA[最近开始学习git的使用，发现snapshot这个术语，看得是朦朦胧胧😀，感觉理解这个词，又感觉不是很懂，所以就去网上搜索资料，尝试用自己的理解叙述出来🤔。 什么是快照 In computer systems, a snapshot is the state of a system at a particular point in time. 本人觉得快照并没含有’速度快’的意思。快照应该理解为整个系统或者应用在某个时刻的状态记录。例如，假定在A时刻，你的git工作空间分别有file1和file2，到B时刻的时候，你对file1进行了修改。 随后，在你准备进行一次commit之前，git就已经准备好快照了，这个快照记录了当前工作空间中指向未修改文件file2的指针和已经修改的file2数据（即当前时刻工作空间的文件数据状态）。因此，commit的时候，就等同于保存了一次快照。 快照怎么进行 git会读取当前工作空间的所有数据，进行数据预存，再重新调整。它会和上一次的快照版本的内容进行比较，对于没有改变的文件数据，git会把当前预存中冗余文件的数据去除掉，改为保留指向上一个版本中该文件数据的指针，对于有差异的文件数据就会保留下来，最终再把数据完整保存下来，这才算是执行了一次快照。 git和CVS,、Subversion等的区别 两者的差异在于对待保存数据的方式。前者是记录和组装一系列快照流的微型系统，关心文件数据的整体是否发生变化。每次commit的时候保存一次快照，而每个快照都包含了完整的数据；后者则关心文件内容的具体差异。第一次保存了完整的数据，往后每次保存的都不是完整的数据，只会记录基于之前的版本和现在两者的变化信息，对于此外没有变化的都不会去记录。 本文参考： . git . quoar]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
