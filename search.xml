<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[认识Java：值传递]]></title>
    <url>%2F08%2F26%2Fpass-by-value.html</url>
    <content type="text"><![CDATA[在数据传递的时候，Java是通过值传递的，也就是说通过拷贝传递。对于主数据类型来说，拷贝它实际的数值；引用类型也只是个变量值，并非是对象本身，所以拷贝的是对象的引用变量值。 概述 主数据类型： 整型：byte、short、int、long 浮点型：float，double 字符型：char 布尔型：boolean 引用类型： 数组 类 接口 形式参数：定义方法时接受数据的参数 实际参数：调用方法时传递数据的参数 值传递（pass by value）：在调用方法时将实际参数复制一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数 引用传递（pass by reference）：在调用方法时将实际参数的地址直接传递到方法中，那么在方法中对参数所进行的修改，将影响到实际参数 主数据类型传递 123456789101112public class Demo1 &#123; public static void main(String[] args) &#123; int x = 7; print(x); System.out.println("print in main method: x is " + x); &#125; public static void print(int x) &#123; x = 13; System.out.println("print in change method: x is " + x); &#125;&#125; 12print in change method: x is 13print in main method: x is 7 可见，change方法内部对x的值的修改并没有改变实际参数x的值。即Java中，主数据类型是值传递的。 引用类型传递 123456789101112public class Demo2 &#123; public static void main(String[] args)&#123; Dog dog = new Dog("哈士奇"); change(dog); System.out.println("print in main method: dog is " + dog); &#125; public static void change(Dog dog) &#123; dog = new Dog("拉布拉多"); System.out.println("print in change method: dog is " + dog); &#125;&#125; 12print in change method: dog is 拉布拉多print in main method: dog is 哈士奇 可见，change方法内部对dog的值的修改并没有改变实际参数dog的值。即Java中，引用类型是值传递的。 总结 在Java中无论什么传递都是值传递，主数据类型本身是数值，所以传递的值就是拷贝的数值，而引用本身是记录对象元数据的变量值，所以传递的值就是拷贝的引用变量值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Java：面向对象]]></title>
    <url>%2F07%2F17%2Fwhat-is-Java.html</url>
    <content type="text"><![CDATA[Java是一种面向对象的静态类型的强语言。采用垃圾自动回收机制通过垃圾收集器（Garbage Collector）回收分配内存，从而实现内存分配和回收的自动管理；采用JVM(Java Virtual Machine)作为运行环境，编译和解释相结合，能够非常容易地获得跨平台能力。 面向对象 概述 面向对象的思维是从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。万物皆为对象，对象具有状态、行为、和标识；程序是对象的集合，他们能通过发送信息来告诉彼此所要做的事情；每个对象都可以由其他对象复合而成；每个对象都拥有自己的类型；某一特定类型的所有对象都可以接受同样的信息。 三大特征 封装，把客观事物抽象成类，一个类就是封装了数据以及操作这些数据的代码的逻辑实体。进行封装后，通过访问权限控制，给对象的内部数据提供了不同级别的保护，从而防止程序意外地改变或错误地使用对象的数据。 继承，创建一个类后，如果另个新类与其具有相似之处，可以以现有的类为基础，复制它，然后进行修改和扩展。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 多态,在处理类型的层次结构时，不把一个对象当做它所属的特定类型对待，在不同情形有不同的表现形式。 五大基本原则 单一职责原则SRP(Single Responsibility Principle)，一个类的功能要尽量单一高内聚 开放封闭原则OCP(Open－Close Principle) ，一个类应该对扩展开放，对修改封闭 替换原则(the Liskov Substitution Principle LSP) ，父类的调用同样适用于子类 依赖原则(the Dependency Inversion Principle DIP)，具体依赖抽象，上层依赖下层 接口分离原则(the Interface Segregation Principle ISP)，针对接口编程，不针对实现编程 拓展 编译型与解释型 概述 编译型：把写好的源程序全部编译成二进制代码的可运行程序 解释型：对写好的源程序中的每行代码逐条解释并计算结果 确定语言的类型 一般，语言只会定义其抽象语义，而不会强制性要求采用某种实现方式，被称为解释型语言还是编译型语言取决于该语言实现程序可执行的主流方式，并不是说解释型语言它就无法编译，反之也是。例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，如Ch。同样，C++也有解释器版本的实现，如Cint。 Java是解释型的吗？ “Java是解释执行”这个说法其实并不太准确。我们开发的Java源代码，首先通过Javac编译成为字节码（bytecode），然后在Java虚拟机（JVM）上运行。而从字节码到在JVM上可运行有三种处理方式： 解释:.class文件经过JVM内嵌的解析器解释执行 编译:JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为&quot;热点代码&quot;编译成本地平台相关的机器码，并进行各种层次的优化 AOT编译器: Java9提供可直接将所有代码编译成可执行的机器码 动态型和静态型 动态类型语言：在运行期间进行类型检查，也就是说在编写代码的时候可以不指定变量的数据类型 静态类型语言：在编译期间进行类型检查，也就是说变量在使用前要声明变量的数据类型，这样的好处是提前检查可能出现的类型错误 强弱语言 强类型：偏向于不容忍隐式类型转换。譬如说Java的int就不能变成double 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double 一次编写，到处运行 一次编写，到处运行，“Write once, run anywhere” (WORA)，表明的是Java的跨平台能力。但是，真的如这句话说得一样完美吗？我想，并不完全是。 WORA是指应用程序生成的二进制文件，可以直接在其他的支持 Java 的平台上运行。 像Linux、Windows和Mac等，这些本质区别很大的平台，他们在一些系统核心调用方面可能存在完全不同的机制，兼容还是有一定的困难的。因而，更广泛意义上的跨平台其实还是比较难实现的。在服务器之外的领域，跨平台要解决的问题更多。 但是，在有限的情况下，完全使用标准jdk，无JNI，无特定硬件依赖的话，Java的跨平台能力还是很强的，利用虚拟机技术，屏蔽了底层硬件、系统的差异，只需把编译好的war、jar包放到已经安装好Java环境的Linux、Windows和Mac等平台下，使用相应的启动脚本，还是可以愉快地跑起来的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解git的快照？]]></title>
    <url>%2F10%2F20%2Fhow-to-understand-snapshot-in-git.html</url>
    <content type="text"><![CDATA[最近开始学习git的使用，发现snapshot这个术语，看得是朦朦胧胧😀，感觉理解这个词，又感觉不是很懂，所以就去网上搜索资料，尝试用自己的理解叙述出来🤔。 什么是快照 In computer systems, a snapshot is the state of a system at a particular point in time. 本人觉得快照并没含有’速度快’的意思。快照应该理解为整个系统或者应用在某个时刻的状态记录。例如，假定在A时刻，你的git工作空间分别有file1和file2，到B时刻的时候，你对file1进行了修改。 随后，在你准备进行一次commit之前，git就已经准备好快照了，这个快照记录了当前工作空间中指向未修改文件file2的指针和已经修改的file2数据（即当前时刻工作空间的文件数据状态）。因此，commit的时候，就等同于保存了一次快照。 快照怎么进行 git会读取当前工作空间的所有数据，进行数据预存，再重新调整。它会和上一次的快照版本的内容进行比较，对于没有改变的文件数据，git会把当前预存中冗余文件的数据去除掉，改为保留指向上一个版本中该文件数据的指针，对于有差异的文件数据就会保留下来，最终再把数据完整保存下来，这才算是执行了一次快照。 git和CVS,、Subversion等的区别 两者的差异在于对待保存数据的方式。前者是记录和组装一系列快照流的微型系统，关心文件数据的整体是否发生变化。每次commit的时候保存一次快照，而每个快照都包含了完整的数据；后者则关心文件内容的具体差异。第一次保存了完整的数据，往后每次保存的都不是完整的数据，只会记录基于之前的版本和现在两者的变化信息，对于此外没有变化的都不会去记录。 本文参考： . git . quoar]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
